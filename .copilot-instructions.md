# GitHub Copilot Instructions for DuckDB FIT Extension

This document provides instructions and context for GitHub Copilot when working on the DuckDB FIT Extension project.

## Project Overview

This is a DuckDB extension that enables reading Garmin `.fit` files using DuckDB. The extension provides table functions to query various aspects of FIT files including:

- **Records**: GPS tracks, heart rate, power, cadence, and other sensor data
- **Activities**: High-level activity metadata and summaries
- **Sessions**: Training session information
- **Laps**: Individual lap data and splits
- **Devices**: Device information and sensor details
- **Events**: Activity events and markers
- **Users**: User profile information

## Architecture

### Core Components

1. **FIT SDK Integration**: Uses Garmin's official FIT SDK (`src/fit-sdk/`) for parsing
2. **Extension Entry Point**: `src/fit_extension.cpp` - main extension implementation
3. **Utilities**: `src/utils.cpp` - helper functions
4. **Build System**: CMake with DuckDB extension template
5. **Testing**: SQL test files in `test/sql/`

### Key Data Structures

```cpp
// Main data structures (defined in fit_extension.cpp)
struct FitRecord      // GPS tracks and sensor data
struct FitActivity    // Activity metadata
struct FitSession     // Session information
struct FitLap         // Lap data
struct FitDevice      // Device information
struct FitEvent       // Events and markers
struct FitUser        // User profile data
```

## Coding Guidelines

### C++ Standards

- Use modern C++ (C++11 minimum, prefer C++14/17 features when available)
- Follow DuckDB coding conventions
- Use `duckdb::` namespace for DuckDB types
- Prefer RAII and smart pointers
- Handle FIT SDK data conversion properly (semicircles to degrees, scaling factors)

### Data Type Mappings

```cpp
// FIT SDK -> DuckDB type mappings
uint8_t  -> LogicalType::UTINYINT
uint16_t -> LogicalType::USMALLINT
uint32_t -> LogicalType::UINTEGER
uint64_t -> LogicalType::UBIGINT
int8_t   -> LogicalType::TINYINT
double   -> LogicalType::DOUBLE
string   -> LogicalType::VARCHAR
FIT timestamp -> LogicalType::TIMESTAMP_TZ
```

### Error Handling

- Always check FIT SDK validity methods (`IsFieldValid()`)
- Handle invalid values (e.g., `0xFFFF`, `0x7FFFFFFF`)
- Provide meaningful error messages for file I/O issues
- Use DuckDB exception types

### Table Functions

- Each table function should have:
  - Bind function (`FitTableBind`, `FitActivitiesBind`, etc.)
  - Execution function (`FitTableFunction`, `FitActivitiesFunction`, etc.)
  - Proper schema definition with correct types
  - Null value handling for missing/invalid data

## File Structure Guidelines

### Source Files (`src/`)

- `fit_extension.cpp`: Main extension logic, table functions, data structures
- `utils.cpp`: Utility functions, data conversion helpers
- `include/`: Header files for public interfaces
- `fit-sdk/`: Garmin FIT SDK (read-only, don't modify)

### Test Files (`test/`)

- `sql/`: SQL test files using DuckDB test runner format
- Test file naming: `fit_*.test`
- Include both positive and negative test cases

### Build Files

- `CMakeLists.txt`: Main CMake configuration
- `extension_config.cmake`: Extension-specific configuration
- `vcpkg.json`: Dependencies (OpenSSL)

## Best Practices for Copilot

### When Writing Code

1. **Context**: Always consider the FIT file format and DuckDB integration
2. **Data Conversion**: Pay attention to FIT SDK scaling factors and unit conversions
3. **Performance**: Batch operations, minimize memory allocations
4. **Testing**: Include test cases for edge cases and error conditions

### When Adding Features

1. **Schema First**: Define the table schema before implementation
2. **Validation**: Add proper data validation and error handling
3. **Documentation**: Update README.md and add inline comments
4. **Tests**: Add corresponding SQL tests

### Common Patterns

```cpp
// Checking for valid FIT data
if (record.IsFieldValid()) {
    uint16_t value = record.GetField();
    if (value != 0xFFFF) { // Check for invalid marker
        fit_record.field = convert_value(value);
    }
}

// Setting DuckDB values with null handling
output.SetValue(col++, row,
    fit_record.field > 0 ? Value::TYPE(fit_record.field) : Value());

// Timestamp conversion (FIT epoch: 1989-12-31)
uint32_t fit_timestamp = record.GetTimestamp();
int64_t unix_timestamp = fit_timestamp + 631065600;
timestamp_t ts = Timestamp::FromEpochSeconds(unix_timestamp);
```

## Testing Guidelines

### SQL Test Format

```sql
# name: test_fit_basic
# description: Test basic FIT file reading

statement ok
LOAD 'build/release/extension/fit/fit.duckdb_extension';

query II
SELECT COUNT(*), COUNT(DISTINCT activity_id)
FROM read_fit('sample.fit');
----
1000  1

# Test with specific columns
query III
SELECT timestamp, latitude, longitude
FROM read_fit('sample.fit')
WHERE latitude IS NOT NULL
LIMIT 3;
```

### Performance Testing

- Test with large FIT files (>100MB)
- Memory usage validation
- Query performance benchmarks

## Dependencies

### Required

- **DuckDB**: Core database engine
- **OpenSSL**: Cryptographic functions (via vcpkg)
- **FIT SDK**: Garmin's official SDK (included)

### Build Tools

- **CMake**: 3.5+
- **Ninja**: Build system (optional, but recommended)
- **vcpkg**: Package manager for dependencies

## Common Issues & Solutions

### Build Issues

- **OpenSSL not found**: Ensure vcpkg is properly configured
- **FIT SDK compilation**: Check C++ standard compatibility
- **DuckDB API changes**: Update to match current DuckDB version

### Runtime Issues

- **Invalid FIT files**: Add file format validation
- **Memory leaks**: Use RAII, check FIT SDK object lifecycle
- **Performance**: Profile with large files, optimize hot paths

### Data Issues

- **Coordinate conversion**: Semicircles to degrees formula
- **Timestamp handling**: FIT epoch vs Unix epoch
- **Unit conversions**: Check FIT SDK documentation for scaling

## Development Workflow

1. **Setup**: Use `GEN=ninja make` to build with Ninja
2. **Testing**: Run `./build/release/duckdb` to test interactively
3. **SQL Tests**: Use DuckDB test runner for automated testing
4. **Performance**: Monitor with representative FIT files

## Extension Functions

Current table functions:

- `read_fit(filename)` - Main records table
- `read_fit_activities(filename)` - Activity metadata
- `read_fit_sessions(filename)` - Session data
- `read_fit_laps(filename)` - Lap information
- `read_fit_devices(filename)` - Device details
- `read_fit_events(filename)` - Event markers
- `read_fit_users(filename)` - User profiles

Future considerations:

- Aggregation functions for sports analytics
- Spatial indexing for GPS tracks
- Integration with DuckDB's spatial extension
